#pos = positon, vel = velocity, mag=magnetic 

def KineticComponet(xVel, yVel):
  return (xVely**2+yVel**2)/2

def magneticPotential(magnField,yPos,xPos,xVel,yVel,charge):
  crossProduct=(yPos*xVel-xPos*yVel)
  magFieldPotential=abs(charge*magField*crossProduct)
  return magFieldPotential
  
def (magField, charge,xPosOrig, yPosnOrig,  xVelOrig, yVelOrig, xPosNow, yPosNow,  xVelNow, yVelNow):
  KCOrig, KCNow=KineticComponet(xVelyOrig, yVelOrig), kineticComponet(xVelNow, yVelNow) 
  magPotentialOrig=magneticPotential(magField,yPosOrig,xPosOrig,xVelOrig,yVelOrig)
  magPotentialNow=magneticPotential(magField,yPosNow,xPosNow,xVelNow,yVelNow)
  diff=KCNow-KCOrig+magPotentialNow-magPotentialOrig
  return abs(diff)

#energy in system must remain constant, that is, potential + kinetic
#This sees if that remains true, mass is ignored because it can be factored out
#magnetic potential comes from charge * MagneticField x Velocity (the Lorentz Force), where cross product is x
#To find the cross product, or to find the component of velocity traveling perpendicular to the magnetic field, 
#if we assume the field is centered at the origin (0,0)
#It is Velocity x Location, dividing by distance from origin would give velocity component in the right direction, but we do not do that as
#that extra distance component converts force to energy
#we need the absolute value of this, as the potential field could be pointing in two different directions towards or away, 
#but we only care about the magnitude
# This loss function makes sure part of physics is followed, but cannot give exact answers


#sine fitting weights
import math

def epochWeightSineForOneWeight(epoch,numberOfLossFunctions,number): 
  #fluctuates weights based on sine curve, making sure always positive, and weights add up to one
  return (math.sin(epoch+2*pi*number/numberOfLossFunctions)+1)/2

def epochWeightSineBased(epoch,numberOfLossFunctions): #does weights for all loss functions 
  weightsArray=[]
  for number in range (0, numberOfLossFunctions):
    weightsArray=weightsArray.append(epochWeightSineForOneWeigh(epoch,numberOfLossFunctions,number)
return weightsArray

#curve fitting fancy

import numpy as np

def curveFancy(loss, weightsList, epochs,numberOfLossFunctions):
  minTodoFancy=numberOfLossFunctions+2
  if epcochs > minTodoFancy: #make sure enoough points for curve fitting, ele use sine funciton above to colect more varied points
    #insert fancy function
    newWeights[newWeights == 0] = 0.1 #make sure no weight is zero, as then no data there and it vanishes
    min=np.min(newWeights)
    if min < 0: newWeights=newWeights+min #no negative weights, as this would make things worse in soem direction
    return newWeights=newWeights/np.linalg.norm(newWeight) #normalized, so its bounded and nothing grows to extreme
else:
  return newWeights=epochWeightSineForOneWeight(epoch,numberOfLossFunctions)

#need to right fancy function still




