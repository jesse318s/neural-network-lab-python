<poml syntax="markdown">

<role>You are an expert machine learning instructor specializing in TensorFlow and custom neural network implementations, with error handling demonstration. </role>

<!-- added above with error handling demonstration.  -->

<task>
Create a comprehensive TensorFlow lab that implements custom weight modification algorithms, adaptive loss functions, and CSV data processing for particle physics simulations. Use the existing code as a starter code example/base, and make the project clean.
</task>

<h>Lab Overview</h>

<p>This lab focuses on advanced TensorFlow techniques including custom weight constraints, adaptive loss functions, and comprehensive performance tracking. Students will work with particle simulation data and implement sophisticated training algorithms.</p>

<h>Requirements</h>

<cp caption="Input Data">
<list>
<item>CSV data containing ten particles with random input parameters</item>
<item>Each particle has final velocity and position outputs</item>
<item>Data represents results from previous program runs</item>
</list>
</cp>

<cp caption="Custom Weight Modifications">
<list listStyle="decimal">
<item><b>Binary Precision Change Control:</b> Implement a function that constrains new weights to have only one additional significant figure in binary format compared to previous weights. Maximum binary digits allowed (excluding trailing zeros and ones).</item>
<item><b>Maximum Binary Precision Control:</b> Implement a function that constraints Maximum binary digits allowed (excluding trailing zeros and ones).</item>
<!-- Split  Binary Precision Control into two functions  -->
<item><b>Oscillation Dampening:</b> Create a function that monitors weight changes across three consecutive epochs. If a weight oscillates (up-down-up or down-up-down pattern), set the smallest non-zero binary digit to zero.</item>
</list>
</cp>

<cp caption="Adaptive Loss Functions">
<list listStyle="decimal">
<item><b>Weighted Combination:</b> Combine two standard loss functions (MSE and MAE) using weighted averages</item>
<item><b>Epoch-Based Weighting:</b> Adjust loss function weights based on current epoch number</item>
<item><b>Accuracy-Based Weighting:</b> Modify weights based on previous epoch's accuracy</item>
<item><b>Loss-Based Weighting:</b> Adapt weights based on previous loss values</item>
</list>
</cp>

<cp caption="Performance Tracking">
<list listStyle="decimal">
<item>Final training accuracy</item>
<item>Epoch with best accuracy and that accuracy value</item>
<item>Epoch with greatest accuracy improvement and that accuracy</item>
<item>Memory size of weight files</item>
<item>Network inference time</item>
<item>What weight function use from adaptive los function, or none if none used </item>
<item> What Custom Weight Modifications used if any </item>
<!-- above two items added  -->
<item>Complete parameter and function configuration log, saves to CSV file with  ID based on date and also rows for each setting used</item>
<!-- Added  saves to CSV file with  ID based on date and also rows for each setting used  -->
</list>
</cp>



<h>Implementation Structure</h>

<section>

<h>Core Components</h>

<code lang="python">
# Classes and functions to implement:

class BinaryWeightConstraintChanges:
    """Manages binary precision of weights changes"""

class BinaryWeightConstraintMax:
    """Manages binary precision of weights max precision"""
    
class OscillationDampener:
    """Prevents weight oscillations"""
    
class AdaptiveLossFunction:
    """Combines multiple loss functions adaptively"""
    
class PerformanceTracker:
    """Tracks and logs training metrics"""
    
def load_particle_data(csv_path):
    """Load and preprocess particle simulation data"""
    
def create_model(input_shape):
    """Build neural network with custom constraints"""
    
def train_with_tracking(model, data, config):
    """Training loop with comprehensive tracking"""
</code>

<h>Binary Weight Management</h>

<code lang="python">
# Weight constraint implementation example:

def constrain_binary_precision_change(current_weights, previous_weights):
    """
    Constrains weights to have max one additional significant binary digit
    
    Args:
        current_weights: New weight values
        previous_weights: Previous epoch weights
        
    Returns:
        Constrained weight values
    """
    # Implementation details here
    pass

def constrain_binary_precision_max(current_weights, max_precision):
    """
    Constrains weights to have max number significant binary digit
    
    Args:
        current_weights: New weight values
        max_precision: max binary precision allowed
        
    Returns:
        Constrained weight values
    """
    # Implementation details here
    pass
<!-- Split  Binary Precision Control into two functions  --> 

def detect_oscillation(weight_history):
    """
    Detects up-down-up or down-up-down patterns
    
    Args:
        weight_history: List of weight values from last 3 epochs
        
    Returns:
        Boolean indicating oscillation detected
    """
    # Implementation details here
    pass
</code>

<h>Adaptive Loss Functions</h>

<code lang="python">
# Custom loss function examples:

def epoch_weighted_loss(epoch, mse_loss, mae_loss):
    """Weight loss functions based on epoch number"""
    # Implementation details here
    pass

def accuracy_weighted_loss(previous_accuracy, mse_loss, mae_loss):
    """Weight loss functions based on previous accuracy"""
    # Implementation details here
    pass

def loss_weighted_loss(previous_loss, mse_loss, mae_loss):
    """Weight loss functions based on previous loss values"""
    # Implementation details here
    pass
</code>

</section>

<examples>
<example>
<input caption="Binary Weight Change Constraint Example">
Previous weight: 1.001 (binary)
Possible new weights: 11.001, 1.0011, 1.1001, 1.0101
Invalid: 11.0011 (too many digits)
</input>
<output caption="Constrained Weight">
Selected: 1.1001 (adds one significant digit)
Constraint satisfied: ✓
</output>
</example>

<example>
<input caption="Binary Weight Max Constraint Example">
Previous weight: 1.001 (binary)
Max Binary Precision: 2
Possible new weight: 1.0
Invalid: 1.001 (too many digits)
</input>
<output caption="Constrained Weight">
Selected: 1.0 (adds one significant digit)
Constraint satisfied: ✓
</output>
</example>

<example>
<input caption="Binary Weight Max Constraint Example">
Previous weight: 1.001 (binary)
Max Binary Precision: 3
Possible new weight: 1.00
Invalid: 1.001 (too many digits)
</input>
<output caption="Constrained Weight">
Selected: 1.00 (adds one significant digit)
Constraint satisfied: ✓
</output>
</example>

<!-- Split  Binary Precision Control into two functions, seocnd function has two examples  --> 

<example>
<input caption="Oscillation Detection">
Weight history: [0.5, 0.7, 0.4] (up-down pattern)
Next update would create: up-down-up
</input>
<output caption="Dampening Applied">
Original weight: 1.1 (binary)
After dampening: 1.0 (smallest non-zero digit set to zero)
</output>
</example>

<example>
<input caption="Adaptive Loss Configuration">
Epoch: 50
Previous accuracy: 0.85
Previous loss: 0.23
MSE: 0.15, MAE: 0.12
</input>
<output caption="Combined Loss">
Epoch weight factor: 0.6
Accuracy weight factor: 0.7
Final loss: 0.6 * 0.15 + 0.4 * 0.12 = 0.138
</output>
</example>
</examples>

<h>Expected Deliverables</h>

<section>

<h>Code Files</h>

<list>
<item><code>main.py</code> - Main training script with all implementations</item>
<item><code>weight_constraints.py</code> - Binary weight management classes</item>
<item><code>adaptive_loss.py</code> - Custom loss function implementations</item>
<item><code>performance_tracker.py</code> - Metrics tracking and CSV output</item>
<item><code>data_loader.py</code> - CSV data loading and preprocessing</item>
<item><code>requirements.txt</code> - Required Python packages</item>
</list>

<h>Output Files</h>

<list>
<item><code>training_results.csv</code> - Complete performance metrics</item>
<item><code>weight_history.csv</code> - Weight evolution tracking</item>
<item><code>loss_history.csv</code> - Loss function components over time</item>
<item><code>model_weights.h5</code> - Final trained model weights</item>
<item><code>training_log.txt</code> - Detailed training configuration and events</item>
</list>

</section>

<h>Evaluation Criteria</h>

<cp caption="Technical Implementation">
<list>
<item><b>Weight Constraints (25%):</b> Correct binary precision control and oscillation dampening</item>
<item><b>Loss Functions (25%):</b> Proper implementation of adaptive weighting schemes</item>
<item><b>Data Processing (20%):</b> Efficient CSV handling and preprocessing</item>
<item><b>Performance Tracking (20%):</b> Comprehensive metrics collection and storage</item>
<item><b>Code Quality (10%):</b> Clean, documented, and modular implementation</item>
</list>
</cp>

<cp caption="Performance Metrics">
<list>
<item>Training convergence within reasonable epochs</item>
<item>Stable weight evolution without excessive oscillation</item>
<item>Accurate tracking of all required performance metrics</item>
<item>Efficient memory usage and execution time</item>
</list>
</cp>

<stepwise-instructions>
<list listStyle="decimal">
<item>Set up the project structure in the python-lab directory</item>
<item>Implement the binary weight constraint classes with proper binary arithmetic</item>
<item>Create the oscillation detection and dampening mechanisms</item>
<item>Develop adaptive loss functions with multiple weighting strategies</item>
<item>Build the performance tracking system with CSV output capabilities</item>
<item>Integrate all components into a cohesive training pipeline</item>
<item>Test with the provided particle simulation data</item>
<item>Validate that all performance metrics are correctly captured</item>
<item>Document the implementation and provide usage examples</item>
<item>Prepare comprehensive test cases and validation scripts</item>
</list>
</stepwise-instructions>

<cp caption="Advanced Challenges">
<list>
<item><b>Memory Optimization:</b> Implement efficient weight storage to minimize memory footprint</item>
<item><b>Parallel Processing:</b> Add support for multi-GPU training with custom constraints</item>
<item><b>Visualization:</b> Create real-time plots of weight evolution and loss adaptation</item>
<item><b>Hyperparameter Tuning:</b> Implement automatic tuning of loss function weights</item>
<item><b>Model Comparison:</b> Compare performance against standard TensorFlow training</item>
<item><b>Model Comparison:</b> Compare performance against standard TensorFlow training</item>



<item><b>Error Handling or Railway</b> If special fucntion does not work, print why and have way to bypass not working function to test next steps. Similar to railrway programming</item>





</list>
</cp>

<output-format>
Provide complete Python implementations for all required components, ensuring they work together seamlessly. Include detailed comments explaining the binary arithmetic, oscillation detection logic, and adaptive weighting mechanisms. All code should be production-ready with proper error handling and validation. Error handling in case piece does not work should be implemented, so that working pieces will still function and be tested.
</output-format>

<hint>Remember that binary weight constraints require careful handling of floating-point precision. Consider using Python's decimal module or custom binary representation for exact control over significant figures.</hint>

</poml>
